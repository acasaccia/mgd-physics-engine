/*
-----------------------------------------------------------------------------
Filename:    PhysicsEngineOgreTest.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "PhysicsEngineOgreTest.h"
#include <sstream>
#include <time.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <iostream>
#include <string>

//-------------------------------------------------------------------------------------
PhysicsEngineOgreTest::PhysicsEngineOgreTest(void)
{
}
//-------------------------------------------------------------------------------------
PhysicsEngineOgreTest::~PhysicsEngineOgreTest(void)
{
	delete mSimulation;
}

//-------------------------------------------------------------------------------------
void PhysicsEngineOgreTest::createScene(void)
{
	mSimulation = new PhysicsEngine::Simulation();
	mSimulation->addGlobalForce("gravity", new vector3(0.0f, -9.8f, 0.0f));

	float sphereRadius = 1.0f;

	Ogre::SceneNode* mSphereNode;
	std::ostringstream oss;

	PhysicsEngine::Terrain* terrain = new PhysicsEngine::Terrain(2,sphereRadius * 200, sphereRadius * 50);
	mSimulation->addRigidBody("Terrain", terrain);

	//Ogre::Plane plane(Ogre::Vector3::UNIT_Y, -10);
	//Ogre::MeshManager::getSingleton().createPlane("plane", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane, 1500,1500,200,200,true,1,5,5,Ogre::Vector3::UNIT_Z);
	//Ogre::Entity* ent = mSceneMgr->createEntity("LightPlaneEntity", "plane");
	//mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(ent);
	//ent->setMaterialName("Examples/GrassFloor");
	
	createOgreTerrain(mSceneMgr, mSceneMgr->getRootSceneNode()->createChildSceneNode(), terrain);

	srand(time(NULL));

	for (int i=0;i<10;i++)
	{
		PhysicsEngine::Sphere* sphere = new PhysicsEngine::Sphere(sphereRadius);
		//sphere->mPosition = vector3(rand()%75-25,rand()%20+30,rand()%75-25);
		sphere->mPosition = vector3(0,500,0);

		oss << "Sphere" << i;

		mSimulation->addRigidBody(oss.str(), sphere);

		// Bind an Ogre Entity *with the same name* as physical entity to have its position
		// updated on each frame (see CustomFrameListener::frameStarted)
		// We would need to couple physics and graphics entity better, but for this example
		// it should be enough
		Ogre::Entity* sphereEntity = mSceneMgr->createEntity(oss.str(), "sphere.mesh");

		mSphereNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
		mSphereNode->attachObject(sphereEntity);
		
		Ogre::Real meshRadius = sphereEntity->getBoundingRadius();
		Ogre::Real scaleFactor = sphereRadius / meshRadius;
		mSphereNode->scale(scaleFactor, scaleFactor, scaleFactor);
		
		oss.str("");
	}

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.2, 0.2, 0.2));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
	l->setType(Ogre::Light::LT_DIRECTIONAL);
	l->setDirection(Ogre::Vector3(1,-1,0).normalisedCopy());
	l->setDiffuseColour(Ogre::ColourValue::White);
	l->setSpecularColour(Ogre::ColourValue::White);

	mCamera->setPosition(Ogre::Vector3(0,65,100));
	mCamera->lookAt(0,0,0);

	mRoot->addFrameListener(new CustomFrameListener(mSceneMgr, mSimulation));
}

/*
-----------------------------------------------------------------------------
CustomFrameListener
-----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------------------------
CustomFrameListener::CustomFrameListener(Ogre::SceneManager* iSceneManager, PhysicsEngine::Simulation* iSimulation)
{
	mSceneManager = iSceneManager;
	mSimulation = iSimulation;
}

//-------------------------------------------------------------------------------------
bool CustomFrameListener::frameStarted(const Ogre::FrameEvent &evt)
{
	// Advance simulation
	//mSimulation->update( evt.timeSinceLastFrame );
	mSimulation->update( 0.02 );

	// Update position of Ogre entities based on physics simulation
	PhysicsEngine::stringToRigidBodyMap::iterator it;
	for (it = mSimulation->mRigidBodies.begin(); it != mSimulation->mRigidBodies.end(); ++it)
	{
		std::string entityName = it->first;
		PhysicsEngine::RigidBody* body = it->second;
		// It's useless to update position for immovable entities
		if (body->mInverseMass != 0)
		{
			Ogre::Vector3 position = Ogre::Vector3( body->mPosition.data() );
			mSceneManager->getEntity(entityName)->getParentNode()->setPosition( position );
		}
	}
	return true;
}

/*
-----------------------------------------------------------------------------
Rendering functions
-----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------------------------
void PhysicsEngineOgreTest::createOgreTerrain(Ogre::SceneManager* iSceneManager, Ogre::SceneNode* iParentNode, const PhysicsEngine::Terrain* iTerrain )
{
	Ogre::ManualObject* terrain = iSceneManager->createManualObject("Terrain");
	terrain->begin("Examples/GrassFloor", Ogre::RenderOperation::OT_TRIANGLE_LIST);

	Ogre::Vector3 leftNeighbour, bottomNeighbour, rightNeighbour, topNeighbour, normal;

	// Load vertexes.
	for (unsigned int r = 0; r < iTerrain->mSquaresNumber; ++r)
	{
		for (unsigned int c = 0; c < iTerrain->mSquaresNumber; ++c)
		{
			real position[3];
			iTerrain->getVertexPosition(r, c, position);

			terrain->position(
				position[0],
				position[1],
				position[2]
			);

			if ( r == 0 || c == 0 || r == iTerrain->mSquaresNumber - 1 || c == iTerrain->mSquaresNumber - 1 ) {
				terrain->normal( 0, 1, 0 );
			} else {
				leftNeighbour = Ogre::Vector3(
					iTerrain->mFieldSize - (r-1 * iTerrain->mSquareSize),
					iTerrain->mVertexes(r-1, c),
					(c * iTerrain->mSquareSize) - iTerrain->mFieldSize
					
				);
				bottomNeighbour = Ogre::Vector3(
					iTerrain->mFieldSize - (r * iTerrain->mSquareSize),
					iTerrain->mVertexes(r, c-1),
					(c-1 * iTerrain->mSquareSize) - iTerrain->mFieldSize
				);
				rightNeighbour = Ogre::Vector3(
					iTerrain->mFieldSize - (r+1 * iTerrain->mSquareSize),
					iTerrain->mVertexes(r+1, c),
					(c * iTerrain->mSquareSize) - iTerrain->mFieldSize
				);
				topNeighbour = Ogre::Vector3(
					iTerrain->mFieldSize - (r * iTerrain->mSquareSize),
					iTerrain->mVertexes(r, c+1),
					(c+1 * iTerrain->mSquareSize) - iTerrain->mFieldSize
				);
				normal = leftNeighbour.crossProduct(bottomNeighbour) + bottomNeighbour.crossProduct(rightNeighbour) + rightNeighbour.crossProduct(topNeighbour) + topNeighbour.crossProduct(leftNeighbour);
				terrain->normal( normal.normalisedCopy() );
			}

			terrain->textureCoord((float)c / (iTerrain->mSquaresNumber/2), (float)r / (iTerrain->mSquaresNumber/2));
		}
	}

	size_t i;

	// Set indexes.
	for (size_t r = 0; r < iTerrain->mSquaresNumber - 1; ++r)
	{
		for (size_t c = 0; c < iTerrain->mSquaresNumber - 1; ++c)
		{
			iTerrain->getTessellationIndexes(r,c)
			i = r * iTerrain->mSquaresNumber + c;
			terrain->index(i);
			i = (r+1) * iTerrain->mSquaresNumber + c;
			terrain->index(i);
			i = (r+1) * iTerrain->mSquaresNumber + c + 1;
			terrain->index(i);

			i = r * iTerrain->mSquaresNumber + c;
			terrain->index(i);
			i = (r+1) * iTerrain->mSquaresNumber + c + 1;
			terrain->index(i);
			i = r * iTerrain->mSquaresNumber + c + 1;
			terrain->index(i);
		}
	}

	terrain->end();
	terrain->convertToMesh("Terrain");

	// Create the Ogre's entity.
	Ogre::Entity* terrainEntity = iSceneManager->createEntity("Terrain");
	Ogre::SceneNode* sceneNode = iParentNode->createChildSceneNode();
	sceneNode->attachObject(terrainEntity);
}

void showWin32Console()
{
    static const WORD MAX_CONSOLE_LINES = 500;
    int hConHandle;
    long lStdHandle;
    CONSOLE_SCREEN_BUFFER_INFO coninfo;
    FILE *fp;
    // allocate a console for this app
    AllocConsole();
    // set the screen buffer to be big enough to let us scroll text
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &coninfo);
    coninfo.dwSize.Y = MAX_CONSOLE_LINES;
    SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE),
    coninfo.dwSize);
    // redirect unbuffered STDOUT to the console
    lStdHandle = (long)GetStdHandle(STD_OUTPUT_HANDLE);
    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
    fp = _fdopen( hConHandle, "w" );
    *stdout = *fp;
    setvbuf( stdout, NULL, _IONBF, 0 );
    // redirect unbuffered STDIN to the console
    lStdHandle = (long)GetStdHandle(STD_INPUT_HANDLE);
    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
    fp = _fdopen( hConHandle, "r" );
    *stdin = *fp;
    setvbuf( stdin, NULL, _IONBF, 0 );
    // redirect unbuffered STDERR to the console
    lStdHandle = (long)GetStdHandle(STD_ERROR_HANDLE);
    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
    fp = _fdopen( hConHandle, "w" );
    *stderr = *fp;
    setvbuf( stderr, NULL, _IONBF, 0 );
    // make cout, wcout, cin, wcin, wcerr, cerr, wclog and clog
    // point to console as well
    std::ios::sync_with_stdio();
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
		showWin32Console();

        // Create application object
        PhysicsEngineOgreTest app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

		FreeConsole();
        return 0;
    }

#ifdef __cplusplus
}
#endif
