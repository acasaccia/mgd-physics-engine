/*
-----------------------------------------------------------------------------
Filename:    PhysicsEngineOgreTest.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "PhysicsEngineOgreTest.h"
#include <sstream>

//-------------------------------------------------------------------------------------
PhysicsEngineOgreTest::PhysicsEngineOgreTest(void)
{
}
//-------------------------------------------------------------------------------------
PhysicsEngineOgreTest::~PhysicsEngineOgreTest(void)
{
}

//-------------------------------------------------------------------------------------
void PhysicsEngineOgreTest::createScene(void)
{
	simulation = new PhysicsEngine::Simulation;
	simulation->addGlobalForce("gravity", new vector3(0.0f, -9.8f, 0.0f));

	float sphereRadius = 25.0f;

	Ogre::SceneNode* mSphereNode;
	std::ostringstream oss;

	for (int i=0;i<10;i++)
	{
		PhysicsEngine::Sphere* sphere = new PhysicsEngine::Sphere(sphereRadius);
		sphere->mPosition = vector3(rand()%1000-500,rand()%200+200,rand()%1000-500);

		oss << "Sphere" << i;

		simulation->addRigidBody(oss.str(), sphere);

		// Bind an Ogre Entity *with the same name* as physical entity to have its position
		// updated on each frame (see CustomFrameListener::frameStarted)
		Ogre::Entity* sphereEntity = mSceneMgr->createEntity(oss.str(), "sphere.mesh");

		mSphereNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
		mSphereNode->attachObject(sphereEntity);
		
		Ogre::Real meshRadius = sphereEntity->getBoundingRadius();
		Ogre::Real scaleFactor = sphereRadius / meshRadius;
		mSphereNode->scale(scaleFactor, scaleFactor, scaleFactor);
		
		oss.flush();
	}

	//Ogre::Plane plane(Ogre::Vector3::UNIT_Y, -50);
	//Ogre::MeshManager::getSingleton().createPlane("plane", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane, 1500,1500,200,200,true,1,5,5,Ogre::Vector3::UNIT_Z);
	//Ogre::Entity* ent = mSceneMgr->createEntity("LightPlaneEntity", "plane");
	//mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(ent);
	//ent->setMaterialName("Examples/GrassFloor");

	PhysicsEngine::Terrain* terrain = new PhysicsEngine::Terrain(50,sphereRadius * 2, 20);
	terrain->mInverseMass = 0;
	createOgreTerrain(mSceneMgr, mSceneMgr->getRootSceneNode()->createChildSceneNode(), terrain);
	simulation->addRigidBody("Terrain", terrain);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.2, 0.2, 0.2));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
	l->setType(Ogre::Light::LT_DIRECTIONAL);
	l->setDirection(Ogre::Vector3(1,-1,0).normalisedCopy());
	l->setDiffuseColour(Ogre::ColourValue::White);
	l->setSpecularColour(Ogre::ColourValue::White);

	mCamera->setPosition(Ogre::Vector3(0,500,1000));
	mCamera->lookAt(0,0,0);

	mRoot->addFrameListener(new CustomFrameListener(mSceneMgr, simulation));
}

/*
-----------------------------------------------------------------------------
CustomFrameListener
-----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------------------------
CustomFrameListener::CustomFrameListener(Ogre::SceneManager* iSceneManager, PhysicsEngine::Simulation* iSimulation)
{
	mSceneManager = iSceneManager;
	mSimulation = iSimulation;
}

//-------------------------------------------------------------------------------------
bool CustomFrameListener::frameStarted(const Ogre::FrameEvent &evt)
{
	// Advance simulation
	mSimulation->update( evt.timeSinceLastFrame );

	// Update position of Ogre entities based on physics simulation
	PhysicsEngine::stringToRigidBodyMap::iterator it;
	for (it = mSimulation->mRigidBodies.begin(); it != mSimulation->mRigidBodies.end(); ++it)
	{
		std::string entityName = it->first;
		PhysicsEngine::RigidBody* body = it->second;
		// It's useless to update position for immovable entities
		if (body->mInverseMass != 0)
		{
			Ogre::Vector3 position = Ogre::Vector3( body->mPosition.data() );

			/////////////////////////////////////////////////////////////////////////////
			// Collision check with plane @todo: organize this into a collisor///////////
			if ( position.y - 12.5f < -50 )
			{
				body->mLinearMomentum *= -body->mRestitutionCoefficient;
				body->mPosition.y() = -50.0f + 12.5f;
			}
			/////////////////////////////////////////////////////////////////////////////

			mSceneManager->getEntity(entityName)->getParentNode()->setPosition( position );
		}
	}
	return true;
}

/*
-----------------------------------------------------------------------------
Rendering functions
-----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------------------------
void PhysicsEngineOgreTest::createOgreTerrain(Ogre::SceneManager* iSceneManager, Ogre::SceneNode* iParentNode, const PhysicsEngine::Terrain* iTerrain )
{
	Ogre::ManualObject* terrain = iSceneManager->createManualObject("Terrain");
	terrain->begin("Examples/GrassFloor", Ogre::RenderOperation::OT_TRIANGLE_LIST);

	size_t heightFieldRows	= iTerrain->mVertexes.rows();
	size_t heightFieldColumns = iTerrain->mVertexes.cols();

	float horizontalScaleFactor = iTerrain->cellSize;

	const float halfWidth	= (heightFieldColumns - 1)	* horizontalScaleFactor / 2.0f;
	const float halfHeight	= (heightFieldRows - 1)		* horizontalScaleFactor / 2.0f;

	Ogre::Vector3 leftNeighbour, bottomNeighbour, rightNeighbour, topNeighbour, normal;

	// Load vertexes.
	for (size_t r = 0; r < heightFieldRows; ++r)
	{
		for (size_t c = 0; c < heightFieldColumns; ++c)
		{
			terrain->position(
				(c * horizontalScaleFactor) - halfWidth, 
				halfHeight - (r * horizontalScaleFactor),
				iTerrain->mVertexes(r, c)
			);

			if ( r == 0 || c == 0 || r == heightFieldRows - 1 || c == heightFieldColumns - 1 ) {
				terrain->normal( 0, 1, 0 );
			} else {
				leftNeighbour = Ogre::Vector3(
					(c * horizontalScaleFactor) - halfWidth, 
					halfHeight - (r-1 * horizontalScaleFactor),
					iTerrain->mVertexes(r-1, c)
				);
				bottomNeighbour = Ogre::Vector3(
					(c-1 * horizontalScaleFactor) - halfWidth, 
					halfHeight - (r * horizontalScaleFactor),
					iTerrain->mVertexes(r, c-1)
				);
				rightNeighbour = Ogre::Vector3(
					(c * horizontalScaleFactor) - halfWidth, 
					halfHeight - (r+1 * horizontalScaleFactor),
					iTerrain->mVertexes(r+1, c)
				);
				topNeighbour = Ogre::Vector3(
					(c+1 * horizontalScaleFactor) - halfWidth, 
					halfHeight - (r * horizontalScaleFactor),
					iTerrain->mVertexes(r, c+1)
				);
				normal = leftNeighbour.crossProduct(bottomNeighbour) + bottomNeighbour.crossProduct(rightNeighbour) + rightNeighbour.crossProduct(topNeighbour) + topNeighbour.crossProduct(leftNeighbour);
				terrain->normal( normal.normalisedCopy() );
			}

			terrain->textureCoord((float)c / 10, (float)r / 10);
		}
	}

	size_t i;

	// Set indexes.
	for (size_t r = 0; r < heightFieldRows - 1; ++r)
	{
		for (size_t c = 0; c < heightFieldColumns - 1; ++c)
		{
			if ((r % 2) == 0)
			{
				// Even row.
				if ((c % 2) == 0)
				{
					// Odd column.
					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);

					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);
					i = r * heightFieldColumns + c + 1;
					terrain->index(i);
				}
				else
				{
					// Even column.
					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + c + 1;
					terrain->index(i);

					i = r * heightFieldColumns + c + 1;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);
				} 
			}
			else 
			{
				// Odd row.
				if ((c % 2) == 0)
				{
					// Odd column.
					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + c + 1;
					terrain->index(i);

					i = r * heightFieldColumns + c + 1;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);
				}
				else
				{
					// Even column.
					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);

					i = r * heightFieldColumns + c;
					terrain->index(i);
					i = r * heightFieldColumns + heightFieldColumns + c + 1;
					terrain->index(i);
					i = r * heightFieldColumns + c + 1;
					terrain->index(i);
				} 
			}
		}
	}

	terrain->end();
	terrain->convertToMesh("Terrain");

	// Create the Ogre's entity.
	Ogre::Entity* terrainEntity = iSceneManager->createEntity("Terrain");
	Ogre::SceneNode* sceneNode = iParentNode->createChildSceneNode();
	sceneNode->attachObject(terrainEntity);
	sceneNode->rotate(Ogre::Quaternion(sqrt(0.5),-sqrt(0.5),0,0));
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        PhysicsEngineOgreTest app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
